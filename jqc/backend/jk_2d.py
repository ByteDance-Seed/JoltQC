# Copyright 2025 ByteDance Inc.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
#

"""
2D algorithm for JK calculations.

The 2D algorithm computes J/K matrices using a 2D grid where:
- Each VJ block processes one ij shell pair and up to 256 kl pairs
- Threads within a VJ block are arranged as (1 x 256) to eliminate padding
- VK blocks retain the legacy (16 x 16) layout and operate on tiled pairs
- Supports arbitrary angular momentum combinations (li, lj, lk, ll)

Angular Momentum Support:
- All combinations from (0,0,0,0) to (4,4,4,4) are supported
- The algorithm is most efficient for low angular momentum (s, p, d shells)
- Higher angular momentum (f, g shells) may require more registers

Pair Format:
- VJ expects flat ij/kl pair lists (no padding) with symmetry handled upstream
- VK continues to use 16-wide padded tiles generated by make_pairs
"""

import warnings

import cupy as cp
import numpy as np

from jqc.backend.cuda_scripts import (
    jk_2d_code,
    jk_2d_vj_code,
    jk_2d_vk_code,
    rys_roots_code,
    rys_roots_data,
)
from jqc.backend.util import generate_lookup_table
from jqc.constants import BASIS_STRIDE, NPRIM_MAX

__all__ = ["gen_kernel", "gen_vj_kernel", "gen_vk_kernel"]

THREADS_VJ = (1, 256)
THREADS_VK = (16, 16)
compile_options = ("-std=c++17", "--use_fast_math", "--minimal")

_script_cache = {}
_script_cache_vj = {}
_script_cache_vk = {}

def gen_code_vj(keys):
    """Generate code for VJ kernel only."""
    if keys in _script_cache_vj:
        return _script_cache_vj[keys]
    ang, nprim, dtype, rys_type, n_dm = keys
    if dtype == np.float64:
        dtype_cuda = "double"
    elif dtype == np.float32:
        dtype_cuda = "float"
    else:
        raise RuntimeError("Data type is not supported")

    li, lj, lk, ll = ang
    npi, npj, npk, npl = nprim
    nroots = (li + lj + lk + ll) // 2 + 1
    const = f"""
typedef unsigned int uint32_t;
using DataType = {dtype_cuda};
constexpr int li = {li};
constexpr int lj = {lj};
constexpr int lk = {lk};
constexpr int ll = {ll};
constexpr int npi = {npi};
constexpr int npj = {npj};
constexpr int npk = {npk};
constexpr int npl = {npl};
constexpr int n_dm = {n_dm};
constexpr int rys_type = {rys_type};   // 0: omega = 0.0; -1: omega < 0.0; 1 omega > 0.0;
// Inject constants to match host-side layout
#define NPRIM_MAX {NPRIM_MAX}
#define BASIS_STRIDE {BASIS_STRIDE}

// for rys_roots
constexpr int nroots = ((li+lj+lk+ll)/2+1);
"""
    idx_script = generate_lookup_table(li, lj, lk, ll)
    script = (
        const + rys_roots_data[nroots] + rys_roots_code + idx_script + jk_2d_vj_code
    )

    _script_cache_vj[keys] = script
    return script

def gen_code_vk(keys):
    """Generate code for VK kernel only."""
    if keys in _script_cache_vk:
        return _script_cache_vk[keys]
    ang, nprim, dtype, rys_type, n_dm = keys
    if dtype == np.float64:
        dtype_cuda = "double"
    elif dtype == np.float32:
        dtype_cuda = "float"
    else:
        raise RuntimeError("Data type is not supported")

    li, lj, lk, ll = ang
    npi, npj, npk, npl = nprim
    nroots = (li + lj + lk + ll) // 2 + 1
    const = f"""
typedef unsigned int uint32_t;
using DataType = {dtype_cuda};
constexpr int li = {li};
constexpr int lj = {lj};
constexpr int lk = {lk};
constexpr int ll = {ll};
constexpr int npi = {npi};
constexpr int npj = {npj};
constexpr int npk = {npk};
constexpr int npl = {npl};
constexpr int n_dm = {n_dm};
constexpr int rys_type = {rys_type};   // 0: omega = 0.0; -1: omega < 0.0; 1 omega > 0.0;
// Inject constants to match host-side layout
#define NPRIM_MAX {NPRIM_MAX}
#define BASIS_STRIDE {BASIS_STRIDE}

// for rys_roots
constexpr int nroots = ((li+lj+lk+ll)/2+1);
"""
    idx_script = generate_lookup_table(li, lj, lk, ll)
    script = (
        const + rys_roots_data[nroots] + rys_roots_code + idx_script + jk_2d_vk_code
    )

    _script_cache_vk[keys] = script
    return script

def gen_code(keys):
    if keys in _script_cache:
        return _script_cache[keys]
    ang, nprim, dtype, rys_type, n_dm, do_j, do_k = keys
    if dtype == np.float64:
        dtype_cuda = "double"
    elif dtype == np.float32:
        dtype_cuda = "float"
    else:
        raise RuntimeError("Data type is not supported")

    li, lj, lk, ll = ang
    npi, npj, npk, npl = nprim
    nroots = (li + lj + lk + ll) // 2 + 1
    const = f"""
typedef unsigned int uint32_t;
using DataType = {dtype_cuda};
constexpr int li = {li};
constexpr int lj = {lj};
constexpr int lk = {lk};
constexpr int ll = {ll};
constexpr int npi = {npi};
constexpr int npj = {npj};
constexpr int npk = {npk};
constexpr int npl = {npl};
constexpr int n_dm = {n_dm};
constexpr int rys_type = {rys_type};   // 0: omega = 0.0; -1: omega < 0.0; 1 omega > 0.0;
constexpr int do_j = {int(do_j)};
constexpr int do_k = {int(do_k)};
// Inject constants to match host-side layout
#define NPRIM_MAX {NPRIM_MAX}
#define BASIS_STRIDE {BASIS_STRIDE}

// for rys_roots
constexpr int nroots = ((li+lj+lk+ll)/2+1);
"""
    idx_script = generate_lookup_table(li, lj, lk, ll)
    script = (
        const + rys_roots_data[nroots] + rys_roots_code + idx_script + jk_2d_code
    )

    _script_cache[keys] = script
    return script

def gen_vj_kernel(
    ang,
    nprim,
    dtype=np.double,
    n_dm=1,
    omega=None,
    print_log=False,
    use_cache=True,
):
    """
    Generate a 2D VJ kernel for given angular momentum and primitives.

    Args:
        ang: Tuple of 4 integers (li, lj, lk, ll) representing angular momenta.
             Supports 0 (s) through 4 (g) for each shell.
        nprim: Tuple of 4 integers specifying number of primitives per shell
        dtype: Data type (np.float32 or np.float64)
        n_dm: Number of density matrices to process
        omega: Range-separation parameter (None for standard integrals)
        print_log: Print kernel info if True
        use_cache: Use cached kernels if available

    Returns:
        Tuple of (script, module, function) where function expects args:
            (nao, basis_data, dm, vj, omega,
             ij_pairs, n_ij_pairs, kl_pairs, n_kl_pairs,
             q_cond_ij, q_cond_kl, log_cutoff)

    Raises:
        RuntimeError: If angular momentum exceeds maximum supported value (4)
                     or if omega value is negative (not supported)
    """
    # Validate angular momentum
    li, lj, lk, ll = ang
    max_l = 4  # Maximum angular momentum (g shell)
    if any(l < 0 or l > max_l for l in ang):
        raise ValueError(
            f"Angular momentum {ang} out of range. Supported: 0 (s) to {max_l} (g)"
        )
    if omega is None:
        rys_type = 0
    elif omega > 0:
        rys_type = 1
    elif omega < 0:
        rys_type = -1
        raise RuntimeError("Omega value is not supported")
    else:
        rys_type = 0

    keys = ang, nprim, dtype, rys_type, n_dm
    script = gen_code_vj(keys)

    if not use_cache:
        # Generate a random number to change the cuda code,
        # such that the compiler will recompile the code
        import random

        x = random.random()
        script += f" \n#define RANDOM_NUMBER {x}"

    mod = cp.RawModule(code=script, options=compile_options)
    kernel_vj = mod.get_function("rys_vj_2d")

    def fun(*args):
        # Args: (nao, basis_data, dm, vj, omega,
        #        ij_pairs, n_ij_pairs, kl_pairs, n_kl_pairs,
        #        q_cond_ij, q_cond_kl, log_cutoff)
        n_ij_pairs = args[6]
        n_kl_pairs = args[8]

        if n_ij_pairs == 0 or n_kl_pairs == 0:
            return

        # VJ: full grid with per-pair screening
        block_vj = THREADS_VJ * 1
        grid_vj = (
            n_ij_pairs,
            (n_kl_pairs + block_vj[1] - 1) // block_vj[1],
        )
        kernel_vj(grid_vj, block_vj, args)

    return script, mod, fun

def gen_vk_kernel(
    ang,
    nprim,
    dtype=np.double,
    n_dm=1,
    omega=None,
    print_log=False,
    use_cache=True,
):
    """
    Generate a 2D VK kernel for given angular momentum and primitives.

    Args:
        ang: Tuple of 4 integers (li, lj, lk, ll) representing angular momenta.
             Supports 0 (s) through 4 (g) for each shell.
        nprim: Tuple of 4 integers specifying number of primitives per shell
        dtype: Data type (np.float32 or np.float64)
        n_dm: Number of density matrices to process
        omega: Range-separation parameter (None for standard integrals)
        print_log: Print kernel info if True
        use_cache: Use cached kernels if available

    Returns:
        Tuple of (script, module, function) where function expects args:
            (nao, basis_data, dm, vk, omega,
             ij_pairs, n_ij_pairs, kl_pairs, n_kl_pairs,
             q_cond_ij, q_cond_kl, log_cutoff)

    Raises:
        RuntimeError: If angular momentum exceeds maximum supported value (4)
                     or if omega value is negative (not supported)
    """
    # Validate angular momentum
    li, lj, lk, ll = ang
    max_l = 4  # Maximum angular momentum (g shell)
    if any(l < 0 or l > max_l for l in ang):
        raise ValueError(
            f"Angular momentum {ang} out of range. Supported: 0 (s) to {max_l} (g)"
        )
    if omega is None:
        rys_type = 0
    elif omega > 0:
        rys_type = 1
    elif omega < 0:
        rys_type = -1
        raise RuntimeError("Omega value is not supported")
    else:
        rys_type = 0

    keys = ang, nprim, dtype, rys_type, n_dm
    script = gen_code_vk(keys)

    if not use_cache:
        # Generate a random number to change the cuda code,
        # such that the compiler will recompile the code
        import random

        x = random.random()
        script += f" \n#define RANDOM_NUMBER {x}"

    mod = cp.RawModule(code=script, options=compile_options)
    kernel_vk = mod.get_function("rys_vk_2d")

    def fun(*args):
        # Args: (nao, basis_data, dm, vk, omega,
        #        ij_pairs, n_ij_pairs, kl_pairs, n_kl_pairs,
        #        q_cond_ij, q_cond_kl, log_cutoff)
        n_ij_pairs = args[6]
        n_kl_pairs = args[8]

        if n_ij_pairs == 0 or n_kl_pairs == 0:
            return

        # VK: 2-fold symmetry with per-pair screening
        block_vk = THREADS_VK
        grid_vk = (n_ij_pairs, n_kl_pairs)
        kernel_vk(grid_vk, block_vk, args)

    return script, mod, fun

def gen_kernel(
    ang,
    nprim,
    dtype=np.double,
    n_dm=1,
    do_j=True,
    do_k=True,
    omega=None,
    print_log=False,
    use_cache=True,
):
    """
    Generate a 2D JK kernel for given angular momentum and primitives.

    This is a wrapper function that calls gen_vj_kernel and/or gen_vk_kernel
    based on the do_j and do_k flags.

    Args:
        ang: Tuple of 4 integers (li, lj, lk, ll) representing angular momenta.
             Supports 0 (s) through 4 (g) for each shell.
        nprim: Tuple of 4 integers specifying number of primitives per shell
        dtype: Data type (np.float32 or np.float64)
        n_dm: Number of density matrices to process
        do_j: Whether to compute J matrix
        do_k: Whether to compute K matrix
        omega: Range-separation parameter (None for standard integrals)
        print_log: Print kernel info if True
        use_cache: Use cached kernels if available

    Returns:
        Tuple of (script, module, function) where function expects args:
            (nao, basis_data, dm, vj, vk, omega,
             ij_pairs, n_ij_pairs, kl_pairs, n_kl_pairs,
             q_cond_ij, q_cond_kl, log_cutoff)

    Raises:
        RuntimeError: If angular momentum exceeds maximum supported value (4)
                     or if omega value is negative (not supported)
    """
    # Generate kernels based on flags
    vj_result = None
    vk_result = None

    if do_j:
        vj_result = gen_vj_kernel(
            ang, nprim, dtype, n_dm, omega, print_log, use_cache
        )

    if do_k:
        vk_result = gen_vk_kernel(
            ang, nprim, dtype, n_dm, omega, print_log, use_cache
        )

    # Combine results
    if do_j and do_k:
        # Both kernels: return combined script and wrapper function
        script_vj, mod_vj, fun_vj = vj_result
        script_vk, mod_vk, fun_vk = vk_result

        # Use a combined script (for backward compatibility)
        script = f"// VJ Kernel:\n{script_vj}\n\n// VK Kernel:\n{script_vk}"

        def fun(*args):
            # Args: (nao, basis_data, dm, vj, vk, omega,
            #        ij_pairs, n_ij_pairs, kl_pairs, n_kl_pairs,
            #        q_cond_ij, q_cond_kl, log_cutoff)
            # Split args for VJ and VK
            vj_args = args[:4] + (args[5],) + args[6:]
            vk_args = args[:3] + (args[4], args[5]) + args[6:]

            fun_vj(*vj_args)
            fun_vk(*vk_args)

        return script, mod_vj, fun

    elif do_j:
        # Only VJ kernel
        script, mod, fun_vj = vj_result

        def fun(*args):
            # Extract VJ args from combined signature
            vj_args = args[:4] + (args[5],) + args[6:]
            fun_vj(*vj_args)

        return script, mod, fun

    elif do_k:
        # Only VK kernel
        script, mod, fun_vk = vk_result

        def fun(*args):
            # Extract VK args from combined signature
            vk_args = args[:3] + (args[4], args[5]) + args[6:]
            fun_vk(*vk_args)

        return script, mod, fun

    else:
        raise ValueError("At least one of do_j or do_k must be True")
