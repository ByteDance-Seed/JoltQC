# Copyright 2025 ByteDance Inc.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
#

"""
Pair-based algorithm for JK calculations.

The pair-based algorithm computes J/K matrices using shell pairs where:
- Each VJ block processes one ij shell pair and up to 256 kl pairs
- Threads within a VJ block are arranged as (1 x 256) to eliminate padding
- VK blocks use (16 x 16) layout and operate on tiled pairs
- Supports arbitrary angular momentum combinations (li, lj, lk, ll)

Pair Format:
- VJ expects flat ij/kl pair lists (no padding) with symmetry handled upstream
- VK uses 16-wide (or 64-wide) padded tiles generated by make_pairs
- All pairs are in (i, j) format ready for CUDA int2 consumption
"""

import cupy as cp
import numpy as np

from jqc.backend.cuda_scripts import (
    jk_pair_vj_code,
    jk_pair_vk_code,
    rys_roots_code,
    rys_roots_data,
)
from jqc.backend.util import generate_lookup_table
from jqc.constants import BASIS_STRIDE, NPRIM_MAX

__all__ = [
    "gen_kernel",
    "gen_vj_kernel",
    "gen_vk_kernel",
    "make_pairs",
    "make_pairs_symmetric",
]

THREADS_VJ = (256, 1)
THREADS_VK = (16, 16)
compile_options = ("-std=c++17", "--use_fast_math", "--minimal")

_script_cache_vj = {}
_script_cache_vk = {}


def make_pairs(l_ctr_bas_loc, q_matrix, cutoff, column_size: int = 16):
    """
    Make shell pairs with GTO pairing screening.

    Returns pairs in (i, j) format ready for CUDA int2 consumption.
    Pairs are arranged in blocks of column_size with (-1, -1) padding.
    The total number of pairs is always a multiple of column_size.

    Args:
        l_ctr_bas_loc: Group boundaries for basis functions
        q_matrix: Schwarz screening matrix
        cutoff: Screening cutoff threshold
        column_size: Size of each tile (default: 16)

    Returns:
        dict: Maps (group_i, group_j) to flat (N, 2) array where N % column_size == 0
    """
    pairs = {}
    n_groups = len(l_ctr_bas_loc) - 1
    nbas = q_matrix.shape[0]
    bas_loc = l_ctr_bas_loc

    # Pre-compute indices to avoid repeated allocations
    i_indices = cp.arange(nbas, dtype=np.int32)
    j_indices = cp.arange(nbas, dtype=np.int32)

    for i in range(n_groups):
        i0, i1 = bas_loc[i], bas_loc[i + 1]
        i_range = i_indices[i0:i1]

        for j in range(n_groups):
            j0, j1 = bas_loc[j], bas_loc[j + 1]
            j_range = j_indices[j0:j1]

            sub_q_idx = q_matrix[i0:i1, j0:j1]
            mask = sub_q_idx > cutoff

            if not mask.any():
                continue

            all_valid_pairs = []
            for idx, sh_i in enumerate(i_range):
                row_mask = mask[idx, :]
                if not row_mask.any():
                    continue

                valid_j_indices = j_range[row_mask]
                q_values = sub_q_idx[idx, :][row_mask]

                # Sort in descending order so the first entry carries the largest q value
                sort_indices = cp.argsort(-q_values)
                sorted_j = valid_j_indices[sort_indices]

                # Create (i, j) pairs
                num_pairs = sorted_j.size
                padded_size = ((num_pairs + column_size - 1) // column_size) * column_size
                if padded_size > 0:
                    # Create padded array with (-1, -1) for invalid pairs
                    padded_row = cp.full((padded_size, 2), -1, dtype=np.int32)
                    padded_row[:num_pairs, 0] = sh_i  # i index
                    padded_row[:num_pairs, 1] = sorted_j  # j index
                    all_valid_pairs.append(padded_row)

            if not all_valid_pairs:
                continue

            # Concatenate all rows to create flat (N, 2) array
            final_pairs = cp.concatenate(all_valid_pairs, axis=0)
            if final_pairs.shape[0] > 0:
                # Return as flat (N, 2) array where N is a multiple of column_size
                pairs[i, j] = cp.ascontiguousarray(final_pairs)

    return pairs


def make_pairs_symmetric(l_ctr_bas_loc, q_matrix, cutoff):
    """
    Make shell pairs with symmetry (i >= j) enforced.

    Returns pairs in (i, j) format ready for CUDA int2 consumption.
    No padding is applied for symmetric pairs.
    """
    pairs = {}
    n_groups = len(l_ctr_bas_loc) - 1
    nbas = q_matrix.shape[0]
    bas_loc = l_ctr_bas_loc

    i_indices = cp.arange(nbas, dtype=np.int32)
    j_indices = cp.arange(nbas, dtype=np.int32)

    for i in range(n_groups):
        i0, i1 = bas_loc[i], bas_loc[i + 1]
        i_range = i_indices[i0:i1]

        for j in range(i + 1):
            j0, j1 = bas_loc[j], bas_loc[j + 1]
            j_range = j_indices[j0:j1]

            sub_q_idx = q_matrix[i0:i1, j0:j1]
            mask = sub_q_idx > cutoff

            if i == j:
                # Keep only the lower-triangular shell pairs for symmetry
                tri_mask = j_range[None, :] <= i_range[:, None]
                mask = cp.logical_and(mask, tri_mask)

            if not mask.any():
                continue

            i_list = []
            j_list = []
            q_list = []

            for idx, sh_i in enumerate(i_range):
                row_mask = mask[idx, :]
                if not row_mask.any():
                    continue

                valid_j_indices = j_range[row_mask]
                q_values = sub_q_idx[idx, :][row_mask]

                # Store i and j separately
                i_list.append(cp.full(valid_j_indices.size, sh_i, dtype=np.int32))
                j_list.append(valid_j_indices)
                q_list.append(q_values)

            if not i_list:
                continue

            # Concatenate and sort by q values
            all_i = cp.concatenate(i_list)
            all_j = cp.concatenate(j_list)
            all_q = cp.concatenate(q_list)

            if all_i.size > 0:
                # Sort by q values in descending order
                order = cp.argsort(-all_q)
                sorted_i = all_i[order]
                sorted_j = all_j[order]

                # Create (N, 2) array for (i, j) pairs
                pair_array = cp.empty((sorted_i.size, 2), dtype=np.int32, order='C')
                pair_array[:, 0] = sorted_i
                pair_array[:, 1] = sorted_j
                pairs[i, j] = cp.ascontiguousarray(pair_array)

    return pairs


def gen_code_vj(keys):
    """Generate code for VJ kernel only."""
    if keys in _script_cache_vj:
        return _script_cache_vj[keys]
    ang, nprim, dtype, rys_type, n_dm, pair_wide = keys
    if dtype == np.float64:
        dtype_cuda = "double"
    elif dtype == np.float32:
        dtype_cuda = "float"
    else:
        raise RuntimeError("Data type is not supported")

    li, lj, lk, ll = ang
    npi, npj, npk, npl = nprim
    nroots = (li + lj + lk + ll) // 2 + 1
    const = f"""
typedef unsigned int uint32_t;
using DataType = {dtype_cuda};
constexpr int li = {li};
constexpr int lj = {lj};
constexpr int lk = {lk};
constexpr int ll = {ll};
constexpr int npi = {npi};
constexpr int npj = {npj};
constexpr int npk = {npk};
constexpr int npl = {npl};
constexpr int n_dm = {n_dm};
constexpr int pair_wide = {pair_wide};
constexpr int rys_type = {rys_type};   // 0: omega = 0.0; -1: omega < 0.0; 1 omega > 0.0;
// Inject constants to match host-side layout
#define NPRIM_MAX {NPRIM_MAX}
#define BASIS_STRIDE {BASIS_STRIDE}

// for rys_roots
constexpr int nroots = ((li+lj+lk+ll)/2+1);
"""
    idx_script = generate_lookup_table(li, lj, lk, ll)
    script = (
        const + rys_roots_data[nroots] + rys_roots_code + idx_script + jk_pair_vj_code
    )

    _script_cache_vj[keys] = script
    return script

def gen_code_vk(keys):
    """Generate code for VK kernel only."""
    if keys in _script_cache_vk:
        return _script_cache_vk[keys]
    ang, nprim, dtype, rys_type, n_dm, pair_wide = keys
    if dtype == np.float64:
        dtype_cuda = "double"
    elif dtype == np.float32:
        dtype_cuda = "float"
    else:
        raise RuntimeError("Data type is not supported")

    li, lj, lk, ll = ang
    npi, npj, npk, npl = nprim
    nroots = (li + lj + lk + ll) // 2 + 1
    const = f"""
typedef unsigned int uint32_t;
using DataType = {dtype_cuda};
constexpr int li = {li};
constexpr int lj = {lj};
constexpr int lk = {lk};
constexpr int ll = {ll};
constexpr int npi = {npi};
constexpr int npj = {npj};
constexpr int npk = {npk};
constexpr int npl = {npl};
constexpr int n_dm = {n_dm};
constexpr int pair_wide = {pair_wide};
constexpr int rys_type = {rys_type};   // 0: omega = 0.0; -1: omega < 0.0; 1 omega > 0.0;
// Inject constants to match host-side layout
#define NPRIM_MAX {NPRIM_MAX}
#define BASIS_STRIDE {BASIS_STRIDE}

// for rys_roots
constexpr int nroots = ((li+lj+lk+ll)/2+1);
"""
    idx_script = generate_lookup_table(li, lj, lk, ll)
    script = (
        const + rys_roots_data[nroots] + rys_roots_code + idx_script + jk_pair_vk_code
    )

    _script_cache_vk[keys] = script
    return script

def gen_vj_kernel(
    ang,
    nprim,
    dtype=np.double,
    n_dm=1,
    omega=None,
    pair_wide=256,
    print_log=False,
    use_cache=True,
):
    """
    Generate a 2D VJ kernel for given angular momentum and primitives.

    Args:
        ang: Tuple of 4 integers (li, lj, lk, ll) representing angular momenta.
             Supports 0 (s) through 4 (g) for each shell.
        nprim: Tuple of 4 integers specifying number of primitives per shell
        dtype: Data type (np.float32 or np.float64)
        n_dm: Number of density matrices to process
        omega: Range-separation parameter (None for standard integrals)
        print_log: Print kernel info if True
        use_cache: Use cached kernels if available

    Returns:
        Tuple of (script, module, function) where function expects args:
            (nao, basis_data, dm, vj, omega,
             ij_pairs, n_ij_pairs, kl_pairs, n_kl_pairs,
             q_cond_ij, q_cond_kl, log_cutoff)

    Raises:
        RuntimeError: If angular momentum exceeds maximum supported value (4)
                     or if omega value is negative (not supported)
    """
    # Validate angular momentum
    li, lj, lk, ll = ang
    max_l = 4  # Maximum angular momentum (g shell)
    if any(l < 0 or l > max_l for l in ang):
        raise ValueError(
            f"Angular momentum {ang} out of range. Supported: 0 (s) to {max_l} (g)"
        )
    if omega is None:
        rys_type = 0
    elif omega > 0:
        rys_type = 1
    elif omega < 0:
        rys_type = -1
        raise RuntimeError("Omega value is not supported")
    else:
        rys_type = 0

    keys = ang, nprim, dtype, rys_type, n_dm, pair_wide
    script = gen_code_vj(keys)

    if not use_cache:
        # Generate a random number to change the cuda code,
        # such that the compiler will recompile the code
        import random

        x = random.random()
        script += f" \n#define RANDOM_NUMBER {x}"

    mod = cp.RawModule(code=script, options=compile_options)
    kernel_vj = mod.get_function("rys_pair_vj")

    def fun(*args):
        # Args: (nao, basis_data, dm, vj, omega,
        #        ij_pairs, n_ij_pairs, kl_pairs, n_kl_pairs,
        #        q_cond_ij, q_cond_kl, log_cutoff)
        n_ij_pairs = args[6]
        n_kl_pairs = args[8]

        if n_ij_pairs == 0 or n_kl_pairs == 0:
            return

        # VJ: Each block processes 256 ij pairs and loops over all kl blocks
        vj_blocksize = 256
        block_vj = (vj_blocksize, 1)
        n_ij_blocks = (n_ij_pairs + vj_blocksize - 1) // vj_blocksize
        grid_vj = (n_ij_blocks, 1)
        kernel_vj(grid_vj, block_vj, args)

    return script, mod, fun

def gen_vk_kernel(
    ang,
    nprim,
    dtype=np.double,
    n_dm=1,
    omega=None,
    pair_wide=64,
    print_log=False,
    use_cache=True,
):
    """
    Generate a 2D VK kernel for given angular momentum and primitives.

    Args:
        ang: Tuple of 4 integers (li, lj, lk, ll) representing angular momenta.
             Supports 0 (s) through 4 (g) for each shell.
        nprim: Tuple of 4 integers specifying number of primitives per shell
        dtype: Data type (np.float32 or np.float64)
        n_dm: Number of density matrices to process
        omega: Range-separation parameter (None for standard integrals)
        pair_wide: Width of tiled pairs (default: 64)
        print_log: Print kernel info if True
        use_cache: Use cached kernels if available

    Returns:
        Tuple of (script, module, function) where function expects args:
            (nao, basis_data, dm, vk, omega,
             ij_pairs, n_ij_pairs, kl_pairs, n_kl_pairs,
             q_cond_ij, q_cond_kl, log_cutoff)

    Raises:
        RuntimeError: If angular momentum exceeds maximum supported value (4)
                     or if omega value is negative (not supported)
    """
    # Validate angular momentum
    li, lj, lk, ll = ang
    max_l = 4  # Maximum angular momentum (g shell)
    if any(l < 0 or l > max_l for l in ang):
        raise ValueError(
            f"Angular momentum {ang} out of range. Supported: 0 (s) to {max_l} (g)"
        )
    if omega is None:
        rys_type = 0
    elif omega > 0:
        rys_type = 1
    elif omega < 0:
        rys_type = -1
        raise RuntimeError("Omega value is not supported")
    else:
        rys_type = 0

    keys = ang, nprim, dtype, rys_type, n_dm, pair_wide
    script = gen_code_vk(keys)

    if not use_cache:
        # Generate a random number to change the cuda code,
        # such that the compiler will recompile the code
        import random

        x = random.random()
        script += f" \n#define RANDOM_NUMBER {x}"

    mod = cp.RawModule(code=script, options=compile_options)
    kernel_vk = mod.get_function("rys_pair_vk")

    def fun(*args):
        # Args: (nao, basis_data, dm, vk, omega,
        #        ij_pairs, n_ij_pairs, kl_pairs, n_kl_pairs,
        #        q_cond_ij, q_cond_kl, log_cutoff)
        # Note: pair_wide is now a compile-time constant, not a runtime argument
        n_ij_pairs = args[6]
        n_kl_pairs = args[8]

        if n_ij_pairs == 0 or n_kl_pairs == 0:
            return

        # VK: 2-fold symmetry with per-pair screening
        block_vk = THREADS_VK
        grid_vk = (n_ij_pairs, n_kl_pairs)
        kernel_vk(grid_vk, block_vk, args)

    return script, mod, fun

def gen_kernel(
    ang,
    nprim,
    dtype=np.double,
    n_dm=1,
    do_j=True,
    do_k=True,
    omega=None,
    pair_wide=64,
    print_log=False,
    use_cache=True,
):
    """
    Generate a 2D JK kernel for given angular momentum and primitives.

    This is a wrapper function that calls gen_vj_kernel and/or gen_vk_kernel
    based on the do_j and do_k flags.

    Args:
        ang: Tuple of 4 integers (li, lj, lk, ll) representing angular momenta.
             Supports 0 (s) through 4 (g) for each shell.
        nprim: Tuple of 4 integers specifying number of primitives per shell
        dtype: Data type (np.float32 or np.float64)
        n_dm: Number of density matrices to process
        do_j: Whether to compute J matrix
        do_k: Whether to compute K matrix
        omega: Range-separation parameter (None for standard integrals)
        pair_wide: Width of tiled pairs for VK kernel (default: 64)
        print_log: Print kernel info if True
        use_cache: Use cached kernels if available

    Returns:
        Tuple of (script, module, function) where function expects args:
            (nao, basis_data, dm, vj, vk, omega,
             ij_pairs, n_ij_pairs, kl_pairs, n_kl_pairs,
             q_cond_ij, q_cond_kl, log_cutoff)

    Raises:
        RuntimeError: If angular momentum exceeds maximum supported value (4)
                     or if omega value is negative (not supported)
    """
    # Generate kernels based on flags
    vj_result = None
    vk_result = None

    if do_j:
        vj_result = gen_vj_kernel(
            ang, nprim, dtype, n_dm, omega, pair_wide, print_log, use_cache
        )

    if do_k:
        vk_result = gen_vk_kernel(
            ang, nprim, dtype, n_dm, omega, pair_wide, print_log, use_cache
        )

    # Combine results
    if do_j and do_k:
        # Both kernels: return combined script and wrapper function
        script_vj, mod_vj, fun_vj = vj_result
        script_vk, mod_vk, fun_vk = vk_result

        # Use a combined script (for backward compatibility)
        script = f"// VJ Kernel:\n{script_vj}\n\n// VK Kernel:\n{script_vk}"

        def fun(*args):
            (
                nao,
                basis_data,
                dm,
                vj_arr,
                vk_arr,
                omega_val,
                ij_pairs,
                n_ij_pairs,
                kl_pairs,
                n_kl_pairs,
                q_cond_ij,
                q_cond_kl,
                log_cutoff,
            ) = args

            vj_args = (
                nao,
                basis_data,
                dm,
                vj_arr,
                omega_val,
                ij_pairs,
                n_ij_pairs,
                kl_pairs,
                n_kl_pairs,
                q_cond_ij,
                q_cond_kl,
                log_cutoff,
            )
            vk_args = (
                nao,
                basis_data,
                dm,
                vk_arr,
                omega_val,
                ij_pairs,
                n_ij_pairs,
                kl_pairs,
                n_kl_pairs,
                q_cond_ij,
                q_cond_kl,
                log_cutoff,
            )

            fun_vj(*vj_args)
            fun_vk(*vk_args)

        return script, mod_vj, fun

    elif do_j:
        # Only VJ kernel
        script, mod, fun_vj = vj_result

        def fun(*args):
            (
                nao,
                basis_data,
                dm,
                vj_arr,
                _,
                omega_val,
                ij_pairs,
                n_ij_pairs,
                kl_pairs,
                n_kl_pairs,
                q_cond_ij,
                q_cond_kl,
                log_cutoff,
            ) = args

            vj_args = (
                nao,
                basis_data,
                dm,
                vj_arr,
                omega_val,
                ij_pairs,
                n_ij_pairs,
                kl_pairs,
                n_kl_pairs,
                q_cond_ij,
                q_cond_kl,
                log_cutoff,
            )
            fun_vj(*vj_args)

        return script, mod, fun

    elif do_k:
        # Only VK kernel
        script, mod, fun_vk = vk_result

        def fun(*args):
            (
                nao,
                basis_data,
                dm,
                _,
                vk_arr,
                omega_val,
                ij_pairs,
                n_ij_pairs,
                kl_pairs,
                n_kl_pairs,
                q_cond_ij,
                q_cond_kl,
                log_cutoff,
            ) = args

            vk_args = (
                nao,
                basis_data,
                dm,
                vk_arr,
                omega_val,
                ij_pairs,
                n_ij_pairs,
                kl_pairs,
                n_kl_pairs,
                q_cond_ij,
                q_cond_kl,
                log_cutoff,
            )
            fun_vk(*vk_args)

        return script, mod, fun

    else:
        raise ValueError("At least one of do_j or do_k must be True")
